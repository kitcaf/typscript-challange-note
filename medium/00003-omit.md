# omit

## 题目描述

<!--info-header-start--><h1>实现 Omit <img src="https://img.shields.io/badge/-%E4%B8%AD%E7%AD%89-d9901a" alt="中等"/> <img src="https://img.shields.io/badge/-%23union-999" alt="#union"/> <img src="https://img.shields.io/badge/-%23built--in-999" alt="#built-in"/></h1><blockquote><p>by Anthony Fu <a href="https://github.com/antfu" target="_blank">@antfu</a></p></blockquote><p><a href="https://tsch.js.org/3/play/zh-CN" target="_blank"><img src="https://img.shields.io/badge/-%E6%8E%A5%E5%8F%97%E6%8C%91%E6%88%98-3178c6?logo=typescript&logoColor=white" alt="接受挑战"/></a> &nbsp;&nbsp;&nbsp;<a href="./README.md" target="_blank"><img src="https://img.shields.io/badge/-English-gray" alt="English"/></a>  <a href="./README.ja.md" target="_blank"><img src="https://img.shields.io/badge/-%E6%97%A5%E6%9C%AC%E8%AA%9E-gray" alt="日本語"/></a>  <a href="./README.ko.md" target="_blank"><img src="https://img.shields.io/badge/-%ED%95%9C%EA%B5%AD%EC%96%B4-gray" alt="한국어"/></a>  <a href="./README.pt-BR.md" target="_blank"><img src="https://img.shields.io/badge/-Portugu%C3%AAs%20(BR)-gray" alt="Português (BR)"/></a> </p><!--info-header-end-->

不使用 `Omit` 实现 TypeScript 的 `Omit<T, K>` 泛型。

`Omit` 会创建一个省略 `K` 中字段的 `T` 对象。

例如：

```ts
interface Todo {
  title: string
  description: string
  completed: boolean
}

type TodoPreview = MyOmit<Todo, 'description' | 'title'>

const todo: TodoPreview = {
  completed: false,
}
```

<!--info-footer-start--><br><a href="../../README.zh-CN.md" target="_blank"><img src="https://img.shields.io/badge/-%E8%BF%94%E5%9B%9E%E9%A6%96%E9%A1%B5-grey" alt="返回首页"/></a> <a href="https://tsch.js.org/3/answer/zh-CN" target="_blank"><img src="https://img.shields.io/badge/-%E5%88%86%E4%BA%AB%E4%BD%A0%E7%9A%84%E8%A7%A3%E7%AD%94-teal" alt="分享你的解答"/></a> <a href="https://tsch.js.org/3/solutions" target="_blank"><img src="https://img.shields.io/badge/-%E6%9F%A5%E7%9C%8B%E8%A7%A3%E7%AD%94-de5a77?logo=awesome-lists&logoColor=white" alt="查看解答"/></a> <hr><h3>相关挑战</h3><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00004-easy-pick/README.zh-CN.md" target="_blank"><img src="https://img.shields.io/badge/-4%E3%83%BB%E5%AE%9E%E7%8E%B0%20Pick-7aad0c" alt="4・实现 Pick"/></a> <!--info-footer-end-->


## 解题思路
`type MyOmit<T, K> = any`这道题其实就是反00004-pick的做法，这个时候就不能直接去遍历K

### 解题核心

- 运用00043-exclude中的**联合类型extends分发的特性**将需要的属性筛出来就ok

### 解题流程

- 第一步：实现找出非包含的联合属性  `Myexclude<T, K> = T extends K ? never : T;`
- 第二步：`{[ in ] : ...}`映射结果即可

## 代码实现

```typescript
type Myexclude<T, K> = T extends K ? never : T;

type MyOmit<T, K extends keyof T> = {
	[P in Myexclude<keyof T, K>]: T[P];
};
```

**问题：无法继承属性的修饰符**

**原因**：TypeScript 只在 [P in keyof T] 这种“标准映射”下自动继承修饰符。

- `[P in keyof T]：TypeScript` 能追踪每个属性的原始修饰符（readonly、optional），所以能自动继承。
- `[P in Myexclude<keyof T, K>]`：TypeScript 认为你在“重新生成”一个新的属性集合，它无法保证这些属性和原类型一一对应，所以不会自动继承修饰符。

```typescript
type A = {
  readonly x: number;
  y: string;
};

type B = {
  [P in keyof A]: A[P];
};
// B 的类型是 { x: number; y: string }，x 不再是 readonly

type F = {
  [P in keyof A]: A[P]; // 不保留
};

type G = {
  +readonly [P in keyof A]: A[P]; // 全部 readonly
};

type H = {
  -readonly [P in keyof A]: A[P]; // 全部去掉 readonly
};
```

因此要保证有修饰符，一定需要`[P in keyof T]`标准映射，再通过as进行对每一个循环单元进行**重映射（那么这里可以定义新的函数转化关系）**

```typescript
type Myexclude<T, K> = T extends K ? never : T;

type MyOmit<T, K extends keyof T> = {
	[P in keyof T as Myexclude<P, K>]: T[P];
};

```

**执行顺序**：

1. `P in keyof T`
这一步是“遍历”T的所有属性名，每次循环取出一个属性名赋值给P。

2. `as Myexclude<P, K>`
这一步是对每个P进行“重映射”或“重命名”：
  - 如果 Myexclude<P, K> 结果是 never，则该属性会被移除（不会出现在最终类型中）。
  - 如果不是 never，则该属性会以 Myexclude<P, K> 的结果为新属性名出现在最终类型中（通常就是P本身）。
3. T[P]
这一步是取出原类型T中P属性的类型，赋值给新类型的对应属性。

**核心：一定要通过标准映射进行初步映射，然后as后面就是一个新的条件转换映射关系（二次筛选）** 

## 知识点总结

一、`as` 在 TypeScript 映射类型中的作用是重映射（重命名）属性名，也可以用来条件过滤属性, **as 让你在映射类型中对每个属性名做“二次处理”**

1. **基本语法**

```typescript
type NewType<T> = {
  [P in keyof T as NewName<P>]: T[P]
}
```
 - `P in keyof T`：遍历原类型的所有属性名
 - `as NewName<P>`：把每个属性名P重命名为`NewName<P>`的结果

2. **常用用法**

```typescript
1）重命名属性
type AddPrefix<T> = {
  [K in keyof T as `prefix_${K & string}`]: T[K]
}
// { prefix_a: ...; prefix_b: ... }

2）条件过滤属性
type OnlyStringKeys<T> = {
  [K in keyof T as K extends string ? K : never]: T[K]
}

4）去除下划线开头的属性
type RemoveUnderscore<T> = {
  [K in keyof T as K extends `_${string}` ? never : K]: T[K]
}
```

3. **拓展用法**

- 可以结合模板字符串类型做复杂重命名
- 可以结合条件类型做复杂过滤
- 可以实现属性名的映射、筛选、格式化等高级类型体操


二、 `[P in keyof T] 标准映射可以包括属性名的修饰符`，可以通过后面加入一个as**进行二次条件转换过滤，里面的每一个输入都是循环的单元项**

## 参考链接

- [原题链接](https://github.com/type-challenges/type-challenges/tree/main/questions/00003-medium-omit)
- [TypeScript 官方文档](https://www.typescriptlang.org/docs/)
