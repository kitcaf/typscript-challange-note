# first

## 题目描述

<!--info-header-start--><h1>第一个元素 <img src="https://img.shields.io/badge/-%E7%AE%80%E5%8D%95-7aad0c" alt="简单"/> <img src="https://img.shields.io/badge/-%23array-999" alt="#array"/></h1><blockquote><p>by Anthony Fu <a href="https://github.com/antfu" target="_blank">@antfu</a></p></blockquote><p><a href="https://tsch.js.org/14/play/zh-CN" target="_blank"><img src="https://img.shields.io/badge/-%E6%8E%A5%E5%8F%97%E6%8C%91%E6%88%98-3178c6?logo=typescript&logoColor=white" alt="接受挑战"/></a> &nbsp;&nbsp;&nbsp;<a href="./README.md" target="_blank"><img src="https://img.shields.io/badge/-English-gray" alt="English"/></a>  <a href="./README.ja.md" target="_blank"><img src="https://img.shields.io/badge/-%E6%97%A5%E6%9C%AC%E8%AA%9E-gray" alt="日本語"/></a>  <a href="./README.ko.md" target="_blank"><img src="https://img.shields.io/badge/-%ED%95%9C%EA%B5%AD%EC%96%B4-gray" alt="한국어"/></a> </p><!--info-header-end-->

实现一个`First<T>`泛型，它接受一个数组`T`并返回它的第一个元素的类型。

例如：

```ts
type arr1 = ['a', 'b', 'c']
type arr2 = [3, 2, 1]

type head1 = First<arr1> // 应推导出 'a'
type head2 = First<arr2> // 应推导出 3
```

<!--info-footer-start--><br><a href="../../README.zh-CN.md" target="_blank"><img src="https://img.shields.io/badge/-%E8%BF%94%E5%9B%9E%E9%A6%96%E9%A1%B5-grey" alt="返回首页"/></a> <a href="https://tsch.js.org/14/answer/zh-CN" target="_blank"><img src="https://img.shields.io/badge/-%E5%88%86%E4%BA%AB%E4%BD%A0%E7%9A%84%E8%A7%A3%E7%AD%94-teal" alt="分享你的解答"/></a> <a href="https://tsch.js.org/14/solutions" target="_blank"><img src="https://img.shields.io/badge/-%E6%9F%A5%E7%9C%8B%E8%A7%A3%E7%AD%94-de5a77?logo=awesome-lists&logoColor=white" alt="查看解答"/></a> <hr><h3>相关挑战</h3><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00015-medium-last/README.zh-CN.md" target="_blank"><img src="https://img.shields.io/badge/-15%E3%83%BB%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0-d9901a" alt="15・最后一个元素"/></a> <!--info-footer-end-->


## 解题思路

### 解题关键

- 我们知道T[number]可以返回元组类型的所有元素类型并组成联合类型
- 同理T[index]可以直接返回某个index的类型

### 解题流程


- 第一步：**判断元组类型是否为空**

判断：分支判断-extend, 元组类型长度：T['length']

1. **直接比较：**
```typescript
T extends [] ? true : false
```
2. 长度比较

```typescript
T['length'] extends 0 ? true : false
```

- 第二步：在非空元组类型的情况**读取下标为0的元素类型**


## 代码实现

```typescript
type First<T extends any[]> = T["length"] extends 0 ? never : T[0];

type First<T extends any[]> = T extends [] ? never : T[0];
```

## 知识点总结

- **空元组判断**

1. **直接比较：**
```typescript
T extends [] ? true : false
```
2. 长度比较

```typescript
T['length'] extends 0 ? true : false
```

- 在ts中, **字面量（如数字、字符串、布尔值等）本身就是一种类型**，称为**字面量类型**，**具有隶属关系**。

```typescript
// 字面量类型属于基础类型
type A = 0;           // 0 是 number 类型的一个字面量类型
type B = "hello";     // "hello" 是 string 类型的一个字面量类型

// 可以用联合类型说明隶属关系
type Num = 0 | 1 | 2; // Num 类型是 number 类型的子集，只能取 0、1、2

// 赋值时，字面量类型可以赋值给基础类型
let x: number = 0;    // ok，0 属于 number
let y: string = "hello"; // ok，"hello" 属于 string

// 反过来，基础类型不能赋值给字面量类型
let z: 0 = 0;         // ok
let w: 0 = 1;         // error，1 不是 0

type typeA = [0, 1, "hello"];
const a: typeA = [0, 3, "lihua"]; // error，3 不是 1，"lihua" 不是 "hello"

```

## 参考链接

- [原题链接](https://github.com/type-challenges/type-challenges/tree/main/questions/00014-easy-first)
- [TypeScript 官方文档](https://www.typescriptlang.org/docs/)
